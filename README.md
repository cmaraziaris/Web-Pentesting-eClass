## Open eClass 2.3

Το repository αυτό περιέχει μια __παλιά και μη ασφαλή__ έκδοση του eclass.
Προορίζεται για χρήση στα πλαίσια του μαθήματος
[Προστασία & Ασφάλεια Υπολογιστικών Συστημάτων (ΥΣ13)](https://ys13.chatzi.org/), __μην τη
χρησιμοποιήσετε για κάνενα άλλο σκοπό__.


### Χρήση μέσω docker
```
# create and start (the first run takes time to build the image)
docker-compose up -d

# stop/restart
docker-compose stop
docker-compose start

# stop and remove
docker-compose down -v
```

To site είναι διαθέσιμο στο http://localhost:8001/. Την πρώτη φορά θα πρέπει να τρέξετε τον οδηγό εγκατάστασης.


### Ρυθμίσεις eclass

- Database
  - Host : `db`
  - User : `root`
  - Password : `1234`
- Ρυθμίσεις συστήματος
  - URL του Open eClass : `http://localhost:8001/` (προσοχή στο τελικό `/`)
  - Όνομα Χρήστη του Διαχειριστή : `drunkadmin`


## 2020 Project 1

Εκφώνηση: https://ys13.chatzi.org/assets/projects/project1.pdf


### Μέλη ομάδας

- sdi1800105, Χαράλαμπος Μαραζιάρης
- sdi1800119, Βησσαρίων Μουτάφης

### Report

Συμπληρώστε εδώ __ένα report__ που
- Να εξηγεί τι είδους αλλαγές κάνατε στον κώδικα για να προστατέψετε το site σας (από την κάθε επίθεση).
- Να εξηγεί τι είδους επιθέσεις δοκιμάσατε στο αντίπαλο site και αν αυτές πέτυχαν.

### Defence
In the following sections we will describe the security holes we found in Open-Eclass. 

#### SQL Injection
The basic source of SQL Injections in the site was the fact that most of the user input in post forms was unsanitized, while the MySQL server was actually printing error messages directly from the database, displaying the whole query and in this way making the forms easy to exploit, to acquire the admin password hash in the database. We managed to defend the following vulnerabilities in a certain level by using proper typecasting (ie. `intval()` function in php) and `mysql_real_escape_string()`.
Some of these security issues are manifested in:
- __Forum Section__, where we could use a url like the following `/modules/phpbb/viewtopic.php?topic=' union select password as topic_title, 1 from eclass.user-- &forum=1')--%20` (add url-encoded blank at the end so the sql comment would work) and the password would display as the topic title in the forums.
- __New Thread/Topic Creation__, by directing to `/modules/phpbb/newtopic.php`, we can add the variable `?forum=` and get a SQL error so that we could actually exploit the query and get the admin password. URL Payload: `?forum=') union select password as forum_name, 2 as forum_access, 1 as forum_id from eclass.user --%20`. After that we can see that there is still an error BUT if we check the path displayed in the upper part of the screen we could notice the password hash Χαρτοφυλάκιο χρήστη » Εισαγωγή στον Κομμουνισμό » Περιοχές Συζητήσεων » **admin password-hash** » Νέο θέμα.
- __Reply Forms in Forums__, where with a similar idea we will get to `/modules/phpbb/reply.php` and we will supply the script with the following parameter list ``` ?Dialog1=on&Dialog2=on&Dialog3=on&Dialog4=on&Dialog5=on&Dialog6=on&message=&forum=1&topic=-1)and 1=2 union select 1,password,3,4 from eclass.user --%20&quote=&submit=Υποβολή``` as we could easily see that the __topic__ parameter is prone to sql injection.
- __Course Unregister__, get to `/modules/unreguser/unregcours.php` and supply the php script with the following parameters ```?cid=' union select password as intitule from user -- &u=1```. As we could see the cid parameter is prone to sql injection.
- __Admin Search/List Users__. This is quite obscure but if we combine *SQLi* to get the password hash and a *Reflected XSS* to get the password and send it to us. The url to direct the admin is `/modules/admin/listusers.php` while the payload for the sql injection is 
```
?user_surname=a' union select '<script>some script to get the pass</script>' as user_id ,password as nom,'3' as prenom,'4' as username,'5' as email,'6' as statut from eclass.user where username='drunkadmin'-- 
&user_firstname=<script>some script to get pass</script>
&user_am=
&user_type=0
&user_registered_at_flag=1
&date= 
&hour=0
&minute=0
&user_email=
&user_username=
&c=searchlist
&search_submit=Αναζήτηση
```

#### XSS (Cross-Site Scripting Attacks)
In general there were many XSS vulnerabilities both *stored* and *reflected* in all of the post forms. This occured due to the fact that the user could pass input
immediately to the back-end processing scripts, bypassing entirely the front-end defences provided by the JS scripts. To defence the Following holes we used the `htmspecialchars` function, filtering php library [HTML-Purifier](https://github.com/ezyang/htmlpurifier) and, as a last resort, the use of a **random nonce** token to prevent executing JS scripts from outside sources.
Some Security holes where the following:
- Everywhere an __SQL error__ occured the user could display plain html code, exploiting the lack of filtering in the error box.
- In __conference section__, the user could just supply any kind of executable code and there would be a *Stored XSS* for anyone watching the chat.
- In the __Forums section__, the browser form was filtered , preventing XSS attacks, but we could easily exploit that the *$_POST['message']* parameter was not sanitized properly and we could bypass the JS sanitization, by just using a test exploit like `?message=<script>alert(1)</script>` and in this way create a *Stored XSS* attack.
- The same as before goes for the newtopic.php, that would create a new topic in forums where either the topic-name or the message could easily be set to executable code.
- In the same section, we could also add a reply to an existing topic in the same way (i.e `/reply.php?Dialog1=on&Dialog2=on&Dialog3=on&Dialog4=on&Dialog5=on&Dialog6=on&message=<script>alert(1)</script>&forum=1&topic=1&quote=&submit=Υποβολή`) that would result to a *Stored XSS* attack in the topic reply section.
- Another possible *XSS* vuln is observed during the insertion of an image. If we set the 'src' to be equal to the page path in Open Eclass site we could display any of the XSS attacks that are diplayed in this section. (We could see the vuln by just setting `src="../../"` and hitting the `Preview` button).
-  Every where the __user details__ (name, last name, etc.) were displayed they were not sanitized. So we could exploit that in `/modules/profile/profile.php` we could generate a post request changing the user details by the url (bypassing any JS sanitization) and creating a stored XSS that it would be displayed anywhere the user first/last name are displayed (almost everywhere).
- In the __agenda__ section the user could change the *year* variable and set it to executable JS code, since the year displayed is not sanitized by the php file. This could create a *Reflected XSS* attack.
- In __password-reset__ section the back end displays the user name and email given by the user. These variables can be given through the URL so by exploiting this and the fact that they are displayed with no sanitization, we could pass something like `/modules/auth/lostpass.php?userName=<script>alert(1)</script>&email=aa@localhost.com&doit=Send` and actually get another *Reflected XSS*.
- During the course unregister action we can also create another *Reflected XSS* attack, in combination with an SQLi attack by using an exploit like the following: `/modules/unreguser/unregcours.php?cid=' union select '<script>console.log("XSS")</script>' as intitule -- %20&u=1` where the **cid** variable is actually displayed from the database unsanitized, so if we change it to a script we could execute JS.
- In admin pages where-ever the a script-like name is displayed __it can be executed__ . For example in `/modules/admin/listusers.php` we can use SQLi to change the username, or the surname of the user to a script (this is like using details of a non-existent user) in order to execute a *Reflected XSS*. 
#### LFI

#### CSRF


