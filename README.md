## Open eClass 2.3

Το repository αυτό περιέχει μια __παλιά και μη ασφαλή__ έκδοση του eclass.
Προορίζεται για χρήση στα πλαίσια του μαθήματος
[Προστασία & Ασφάλεια Υπολογιστικών Συστημάτων (ΥΣ13)](https://ys13.chatzi.org/), __μην τη
χρησιμοποιήσετε για κάνενα άλλο σκοπό__.


### Χρήση μέσω docker
```
# create and start (the first run takes time to build the image)
docker-compose up -d

# stop/restart
docker-compose stop
docker-compose start

# stop and remove
docker-compose down -v
```

To site είναι διαθέσιμο στο http://localhost:8001/. Την πρώτη φορά θα πρέπει να τρέξετε τον οδηγό εγκατάστασης.


### Ρυθμίσεις eclass

- Database
  - Host : `db`
  - User : `root`
  - Password : `1234`
- Ρυθμίσεις συστήματος
  - URL του Open eClass : `http://localhost:8001/` (προσοχή στο τελικό `/`)
  - Όνομα Χρήστη του Διαχειριστή : `drunkadmin`


## 2020 Project 1

Εκφώνηση: https://ys13.chatzi.org/assets/projects/project1.pdf


### Μέλη ομάδας

- sdi1800105, Χαράλαμπος Μαραζιάρης
- sdi1800119, Βησσαρίων Μουτάφης

### Report

Συμπληρώστε εδώ __ένα report__ που
- Να εξηγεί τι είδους αλλαγές κάνατε στον κώδικα για να προστατέψετε το site σας (από την κάθε επίθεση).
- Να εξηγεί τι είδους επιθέσεις δοκιμάσατε στο αντίπαλο site και αν αυτές πέτυχαν.

### Defence
In the following sections we will describe the security holes we found in Open-Eclass. 
#### SQL Injection

#### XSS (Cross-Site Scripting Attacks)
In general there were many XSS vulnerabilities both *stored* and *reflected* in all of the post forms. This occured due to the fact that the user could pass input
immediately to the back-end processing scripts, bypassing entirely the front-end defences provided by the JS scripts.
Some Security holes where the following:
- Everywhere an __SQL error__ occured the user could display plain html code, exploiting the lack of filtering in the error box.
- In __conference section__, the user could just supply any kind of executable code and there would be a *Stored XSS* for anyone watching the chat.
- In the __Forums section__, the browser form was filtered , preventing XSS attacks, but we could easily exploit that the *$_POST['message']* parameter was not sanitized properly and we could bypass the JS sanitization, by just using a test exploit like *?message=<script>alert(1)</script>* and in this way create a *Stored XSS* attack.
- The same as before goes for the newtopic.php, that would create a new topic in forums where either the topic-name or the message could easily be set to executable code.
- In the same section, we could also add a reply to an existing topic in the same way (i.e */reply.php?Dialog1=on&Dialog2=on&Dialog3=on&Dialog4=on&Dialog5=on&Dialog6=on&message=<script>alert(1)</script>&forum=1&topic=1&quote=&submit=Υποβολή*) that would result to a *Stored XSS* attack in the topic reply section.
- Another possible *XSS* vuln is observed during the insertion of an image. If we set the 'src' to be equal to the page path in Open Eclass site we could display any of the XSS attacks that are diplayed in this section. (We could see the vuln by just setting src="../../" and hitting the *Preview* button).
-  Every where the __user details__ (name, last name, etc.) were displayed they were not sanitized. So we could exploit that in /modules/profile/profile.php we could generate a post request changing the user details by the url (bypassing any JS sanitization) and creating a stored XSS that it would be displayed anywhere the user first/last name are displayed (almost everywhere).
- In the __agenda__ section the user could change the *year* variable and set it to executable JS code, since the year displayed is not sanitized by the php file. This could create a *Reflected XSS* attack.
- In __password-reset__ section the back end displays the user name and email given by the user. These variables can be given through the URL so by exploiting this and the fact that they are displayed with no sanitization, we could pass something like */modules/auth/lostpass.php?userName=<script>alert(1)</script>&email=aa@localhost.com&doit=Send* and actually get another *Reflected XSS*.
- During the course unregister action we can also create another *Reflected XSS* attack, in combination with an SQLi attack by using an exploit like the following: */modules/unreguser/unregcours.php?cid=' union select '<script>console.log("XSS")</script>' as intitule -- %20&u=1* where the **cid** variable is actually displayed from the database unsanitized, so if we change it to a script we could execute JS.
- In admin pages where-ever the a script-like name is displayed __it can be executed__ . For example in */modules/admin/listusers.php* we can use SQLi to change the username, or the surname of the user to a script (this is like using details of a non-existent user) in order to execute a *Reflected XSS*. 
#### LFI

### CSRF


