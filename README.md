## Open eClass 2.3

Το repository αυτό περιέχει μια __παλιά και μη ασφαλή__ έκδοση του eclass.
Προορίζεται για χρήση στα πλαίσια του μαθήματος
[Προστασία & Ασφάλεια Υπολογιστικών Συστημάτων (ΥΣ13)](https://ys13.chatzi.org/), __μην τη
χρησιμοποιήσετε για κάνενα άλλο σκοπό__.


### Χρήση μέσω docker
```
# create and start (the first run takes time to build the image)
docker-compose up -d

# stop/restart
docker-compose stop
docker-compose start

# stop and remove
docker-compose down -v
```

To site είναι διαθέσιμο στο http://localhost:8001/. Την πρώτη φορά θα πρέπει να τρέξετε τον οδηγό εγκατάστασης.


### Ρυθμίσεις eclass

- Database
  - Host : `db`
  - User : `root`
  - Password : `1234`
- Ρυθμίσεις συστήματος
  - URL του Open eClass : `http://localhost:8001/` (προσοχή στο τελικό `/`)
  - Όνομα Χρήστη του Διαχειριστή : `drunkadmin`


## 2020 Project 1

Εκφώνηση: https://ys13.chatzi.org/assets/projects/project1.pdf


### Μέλη ομάδας

- sdi1800105, Χαράλαμπος Μαραζιάρης
- sdi1800119, Βησσαρίων Μουτάφης

### Report

Συμπληρώστε εδώ __ένα report__ που
- Να εξηγεί τι είδους αλλαγές κάνατε στον κώδικα για να προστατέψετε το site σας (από την κάθε επίθεση).
- Να εξηγεί τι είδους επιθέσεις δοκιμάσατε στο αντίπαλο site και αν αυτές πέτυχαν.

### Defence
In the following sections we will describe the security holes we found in Open-Eclass. 

#### SQL Injection
The basic source of SQL Injections in the site was the fact that most of the user input in post forms was unsanitized, while the MySQL server was actually printing error messages directly from the database, displaying the whole query and in this way making the forms easy to exploit, to acquire the admin password hash in the database. We managed to defend the following vulnerabilities in a certain level by using proper typecasting (ie. `intval()` function in php) and `mysql_real_escape_string()`.
Some of these security issues are manifested in:
- __Forum Section__, where we could use a url like the following `/modules/phpbb/viewtopic.php?topic=' union select password as topic_title, 1 from eclass.user-- &forum=1')--%20` (add url-encoded blank at the end so the sql comment would work) and the password would display as the topic title in the forums.
- __New Thread/Topic Creation__, by directing to `/modules/phpbb/newtopic.php`, we can add the variable `?forum=` and get a SQL error so that we could actually exploit the query and get the admin password. URL Payload: `?forum=') union select password as forum_name, 2 as forum_access, 1 as forum_id from eclass.user --%20`. After that we can see that there is still an error BUT if we check the path displayed in the upper part of the screen we could notice the password hash Χαρτοφυλάκιο χρήστη » Εισαγωγή στον Κομμουνισμό » Περιοχές Συζητήσεων » **admin password-hash** » Νέο θέμα.
- __Reply Forms in Forums__, where with a similar idea we will get to `/modules/phpbb/reply.php` and we will supply the script with the following parameter list ``` ?Dialog1=on&Dialog2=on&Dialog3=on&Dialog4=on&Dialog5=on&Dialog6=on&message=&forum=1&topic=-1)and 1=2 union select 1,password,3,4 from eclass.user --%20&quote=&submit=Υποβολή``` as we could easily see that the __topic__ parameter is prone to sql injection.
- In the **Assignments/Work section**, an SQLi attack can be carried out, by exploiting the `id` parameter of the GET request, which is not checked to be numeric by the back-end component, and is then used to perform *UPDATE* queries to the DB.
- __Course Unregister__, get to `/modules/unreguser/unregcours.php` and supply the php script with the following parameters ```?cid=' union select password as intitule from user -- &u=1```. As we could see the cid parameter is prone to sql injection.
- **Admin Search/Search User**, `http://localhost:8001/modules/admin/search_user.php` every field in this form is SQLi-prone.
- __Admin Search/List Users__. This is quite obscure but if we combine *SQLi* to get the password hash and a *Reflected XSS* to get the password and send it to us. The url to direct the admin is `/modules/admin/listusers.php` while the payload for the sql injection is 
```
?user_surname=a' union select '<script>some script to get the pass</script>' as user_id ,password as nom,'3' as prenom,'4' as username,'5' as email,'6' as statut from eclass.user where username='drunkadmin'-- 
&user_firstname=<script>some script to get pass</script>
&user_am=
&user_type=0
&user_registered_at_flag=1
&date= 
&hour=0
&minute=0
&user_email=
&user_username=
&c=searchlist
&search_submit=Αναζήτηση
```

#### XSS (Cross-Site Scripting Attacks)

In general there were many XSS vulnerabilities both *stored* and *reflected* in all of the post forms. This occured due to the fact that the user could pass input
immediately to the back-end processing scripts, bypassing entirely the front-end defences provided by the JS scripts. To defence the Following holes we used the `htmspecialchars` function, filtering php library [HTML-Purifier](https://github.com/ezyang/htmlpurifier) and, as a last resort, the use of a **random nonce** token to prevent executing JS scripts from outside sources.
Some Security holes where the following:
- Everywhere an __SQL error__ occured the user could display plain html code, exploiting the lack of filtering in the error box.
- In __conference section__, the user could just supply any kind of executable code and there would be a *Stored XSS* for anyone watching the chat.
- In the __Forums section__, the browser form was filtered , preventing XSS attacks, but we could easily exploit that the *$_POST['message']* parameter was not sanitized properly and we could bypass the JS sanitization, by just using a test exploit like `?message=<script>alert(1)</script>` and in this way create a *Stored XSS* attack.
- The same as before goes for the newtopic.php, that would create a new topic in forums where either the topic-name or the message could easily be set to executable code.
- In the same section, we could also add a reply to an existing topic in the same way (i.e `/reply.php?Dialog1=on&Dialog2=on&Dialog3=on&Dialog4=on&Dialog5=on&Dialog6=on&message=<script>alert(1)</script>&forum=1&topic=1&quote=&submit=Υποβολή`) that would result to a *Stored XSS* attack in the topic reply section.
- Another possible *XSS* vuln is observed during the insertion of an image. If we set the 'src' to be equal to the page path in Open Eclass site we could display any of the XSS attacks that are diplayed in this section. (We could see the vuln by just setting `src="../../"` and hitting the `Preview` button).
- In the **Exchange File section**, a persistent XSS attack is achieved in the **Upload File** functionality, where the `Sender`, `Description` and (maybe) `Title` fields are stored and displayed unsanitized in the DB and the front-end.
- In the **Assignments/Work section**, a persistent XSS attack is achieved, exactly the same way we described above.
- Furthermore, a temporary XSS/SQLi attack can be carried out, by exploiting the errors displayed (and executed) in the browser by SQL, in the `id` parameter of the GET request.
An example of a malicious input is: `http://localhost:8001/modules/work/work.php?id='--<script>alert(1);</script>`.
-  Every where the __user details__ (name, last name, etc.) were displayed they were not sanitized. So we could exploit that in `/modules/profile/profile.php` we could generate a post request changing the user details by the url (bypassing any JS sanitization) and creating a stored XSS that it would be displayed anywhere the user first/last name are displayed (almost everywhere).
- In the __agenda__ section the user could change the *year* variable and set it to executable JS code, since the year displayed is not sanitized by the php file. This could create a *Reflected XSS* attack.
- In __password-reset__ section the back end displays the user name and email given by the user. These variables can be given through the URL so by exploiting this and the fact that they are displayed with no sanitization, we could pass something like `/modules/auth/lostpass.php?userName=<script>alert(1)</script>&email=aa@localhost.com&doit=Send` and actually get another *Reflected XSS*.
- During the course unregister action we can also create another *Reflected XSS* attack, in combination with an SQLi attack by using an exploit like the following: `/modules/unreguser/unregcours.php?cid=' union select '<script>console.log("XSS")</script>' as intitule -- %20&u=1` where the **cid** variable is actually displayed from the database unsanitized, so if we change it to a script we could execute JS.
- In admin pages where-ever the a script-like name is displayed __it can be executed__ . For example in `/modules/admin/listusers.php` we can use SQLi to change the username, or the surname of the user to a script (this is like using details of a non-existent user) in order to execute a *Reflected XSS*.

- In **Admin Announcements**, (http://localhost:8001/modules/admin/adminannouncements.php) persistent XSS attacks can be carried out, due to the unsanitized store and display of the form's input fields.
- In **Course Units**, (http://localhost:8001/modules/units/info.php) (admin-side only) an attack can be carried out as described above.
- *Note*: The admin-side XSS attacks, in order to succeed, should be carried out in cooperation with a successful CSRF attack (the other scenario being that the admin him/herself is malicious, which is obviously unexpected).


#### File Injections

Remote/Local File Inclusion vulnerabilities were found in the course tools: `File Exchange` and `Assignments/Work`.

In both cases, every user was able to submit malicious *.php*, *.html*, *.htm* and *.js* files.

- In the case of `File Exchange`, every file is stored under the path `openeclass/courses/<course id>/dropbox/` and is given a randomized name, as a defence mechanism.
However, if the attacker somehow obtains the full path of the file, say by a web-spider, then they can forward the malicious file to another user (via sharing the URL), and the file will be executed to the victims browser.

- In the case of `Assignments/Work`, every file is stored under the path `openeclass/courses/<course id>/work/<randomized dir name>/<lastname firstname id>.<file extension>`, where `<randomized dir name>` is a self-explainatory defence mechanism as before.
Again, if the attacker obtains the full path of the file, they can perform the same attack discussed before.

**Defence**

Our core defence mechanism is the prevention of indexing of the files under `/courses/` to make it really hard for anyone to find the randomized names given to folders that contain (potentially malicious) user files. We achieved that by adding restrictions to the `000-default.conf` file, in combination with an `.htaccess` file.

As an extra -yet not perfect- defence measure, we filter file extensions so they **cannot** be executed through a web-browser, even if the attacker somehow acquires the URL (which includes randomized elements).
In this spirit, we convert *.php*, *.html*, *.htm* and *.js* extensions to *.maybe_phps*, *.maybe_html*, *.maybe_html* and *.maybe_javasc* respectively, and we store the files with the converted/filtered extensions.

To tackle a vulnerability where `.html` files were executed locally when attempting to download them, we disabled file content "hints" that were added to the HTTP Request headers, thus forcing the download. (`modules/dropbox/dropbox_download.php`)


#### CSRF

The website didn't have any protection against CSRF attacks *at all*. The vulnerabilities of this kind are too many too many to be mentioned in a single report, but can found tracking the corresponding Github commits.

We did our best tracking and patching most (if not all) POST forms and GET requests, focusing on the admin-side forms/requests.
The patch is achieved by generating CSRF tokens for each requests and storing them in an array, namely `$_SESSION['csrf_tokens']`, until they're verified by the server (and thus are deleted).


#### Note: Security Functions

Our anti-XSS/CSRF functions can be found here: `openeclass/include/security_functions.php` .


### Attack

In the following sections we will describe the attacks performed in an attempt to gain unauthorized access in the Open-Eclass website protected by team **everbreach**. 


#### SQL Injection



#### XSS (Cross-Site Scripting Attacks)

* **Work/Assignments**: A temporary XSS attack can be performed by exploiting the website's handling of SQL errors (that is, displaying and executing the error strings) in the *Work* section.
Each assignment is characterized by an `ID`, and when viewing the assignment, the user is navigated to this link:
`<team name>.csec.chatzi.org/modules/work/work.php?id=<Assignment ID>`.
Thus, a malicious link exploiting the above vulnerability is:
`<team name>.csec.chatzi.org/modules/work/work.php?id=%27--%3Cscript%3Ealert(1);%3C/script%3E`



#### File Injections/XSS

We couldn't inject `.php` files.
However, we were managed to inject `.html` pages, containing malicious `javascript` code.

The points of entry we exploited are the following:

* **Work/Assignments**: By submitting any file, eclass would show us the directory path storing our file in the target server. Knowing the directory path we were able to figure out the absolute filepath, by guessing the naming convesion, based on the initial eclass version known to every team (that filepath is: `<team name>.csec.chatzi.org/courses/<course ID>/work/<dir name>/<User last name> <User first name> <User ID>.<original file extension>` ).

Furthermore, by navigating to the filepath our malicious `.html` page (and its full functionality) is being displayed to the client's browser.
Thus, the only thing left to do was to forward it to the opposing administrator, and let our malicious scripts do the work on their browser.

* **File Exchange**: This exploit is similar to the one described above.
This time, by submitting a file, the file would get a unique ID to identify it among every exchanged file in the server. The link pointing to the file can be used in the same manner as described before, namely to run malicious scripts to every user's browser (not just the administrator's).

The link is of the following structure: `<team name>.csec.chatzi.org/modules/dropbox/dropbox_download.php?id=<message ID>`.

This is an incredibly generic and easy attack, that doesn't require any information regarding *how* the file is stored in the backend.

The vulnerability is caused by a policy of the eclass developers, that the browser should be "tipped", through the HTTP request, to display certain file types (including `.html` files), instead of showing a *download dialog* window.


#### CSRF

In order to perform CSRF attacks we used an external website (outside Eclass), hoping to trick the opposing administrator into clicking malicious links.

We carried out the following attacks (showcased in `/puppies/1st_round/index.html`):

* [Fail] Unauthorized course deletion via GET request.

`http://everbreach.csec.chatzi.org/modules/amdinplaftormas/delcours.php?c=TMA102&delete=yes`

* [Fail] Submission of customized *eclassconf.php* settings via a form.

* [Success] Unauthorized deletion of users:

`<a href="http://everbreach.csec.chatzi.org/modules/amdinplaftormas/unreguser.php?u=[user to be deleted ID]&c=&doit=yes> </a>`

* [Success] Unauthorized *Administrator status* grant to custom user: 

`<a href="http://everbreach.csec.chatzi.org/modules/user/user.php?giveAdmin=[malicious user ID]"> </a>`