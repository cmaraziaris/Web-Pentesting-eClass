
:- lib(ic).
:- lib(branch_and_bound).

games_csp(Ps,T,K,Gs, Actual_P):- 
    length(Ps, N), 
    length(Gs, N), 
    Gs #:: 1..T,
    solution_cost_as_expression(Gs, Ps, List),
    writeln(Gs), writeln(List),
    P #= - sum(List),
    constraints(Gs, T, K),
    bb_min(search(Gs, 0 , input_order, indomain, complete, []), P, bb_options{solutions:all}),
    %search(Gs, 0 , input_order, indomain, bb_min(P), []),
    Actual_P is -P.


constraints([X |L], T, K):-
    C #= ,  %%%% Added
    constraints(L, T, K, T-X+K).
constraints([], _, _, _).
constraints( [X | L], T, K, Cost_expr):-
    X #=< min(T, Cost_expr),
    New #= min(T, Cost_expr)-X+K,  %%%% Added
    constraints( L, T, K, New).    %%%% Changed

%solution_cost_as_expression(Variable_list, Ps, Cost_expr).
%Create the expression which represents the cost as a function of the variables 
solution_cost_as_expression([X | L1], [Y | L2], Cost):- solution_cost_as_expression(L1, L2, [X*Y], Cost).
solution_cost_as_expression([], [], List, List).
solution_cost_as_expression([X | L1], [Y | L2], List, Cost):- 
    Y < 0, ! , X  #= 1, %A game with negative preference, is always played only once in an optimal solution
    solution_cost_as_expression(L1, L2, [X*Y | List], Cost). %Since the game will only be played once, just add Y to the cost

solution_cost_as_expression([X | L1], [Y | L2], List, Cost):- 
    solution_cost_as_expression(L1, L2, [X*Y | List], Cost).